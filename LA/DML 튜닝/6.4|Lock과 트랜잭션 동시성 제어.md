## 오라클 Lock

오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML Lock, DDL Lock, 래치, 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용한다.

이들 중, 애플리케이션 개발 측면에서 가장 중요하게 다루어야 할 Lock은 무엇보다 `DML Lock`이다. DML Lock은 `다중 트랜잭션이 동시에 엑세스하는 사용자 데이터의 무결성을 보호`해 준다. DML Lock에는 테이블 Lock과 로우 Lock이 있다.

### DML 로우 Lock
DML 로우 Lock은, 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다. 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야 한다.

어떤 DBMS든 DML 로우 Lock에는 배타적 모드를 사용하므로 UPDATE, DELETE를 진행 중인 로우를 다른 트랜잭션이 UPDATE, DELETE 할 수 없다.

INSERT에 대한 로우 Lock 경합은 `Uniuqe 인덱스가 있을 때만 발생`한다.

MVCC 모델을 사용하는 DBMS(오라클, MySQL)는 `SELECT 문에 로우 Lock을 사용하지 않는다.` 다른 트랜잭션이 변경한 로우를 읽을 때 복사본 블록을 만들어서 쿼리가 '시작된 시점'으로 되돌려서 읽는다. 변경이 진행 중인 로우를 읽을 때도 Lock이 풀릴 때까지 기다리지 않고 복사본을 만들어서 읽는다. 따라서 SELECT 문에 Lock을 사용할 필요가 없다.

결국, 오라클에서는 DML과 SELECT는 서로 방해하지 않는다. 물론 SELECT끼리도 방해하지 않는다. 단, `DML끼리는 서로 방해할 수 있다.` 이는 어떤 DMBS를 사용하더라도 마찬가지다.

DML 로우 Lock에 의한 성능 저하를 방지하려면, 온라인 트랜잭션을 처리하는 주간에 `Lock을 필요 이상으로 오래 유지하지 않도록 커밋 시점을 조절해야 한다.`


### DML 테이블 Lock
오라클은 DML 로우 Lock을 설정하기에 앞서 `테이블 Lock을 먼저 설정`한다. 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위해서다. 테이블 Lock을 'TM Lock'이라고 부르기도 한다.

오라클은 로우 Lock에는 항상 배타적 모드를 사용하지만, 테이블 Lock에는 여러 가지 Lock 모드를 사용한다.

선행 트랜잭션과 호환되지 않는 모드로 테이블 Lock을 설정하려는 후행 트랜잭션은 대기하거나 작업을 포기해야 한다.

INSERT, UPDATE, DELETE, MERGE 문을 위해 로우 Lock을 설정하려면 해당 테이블에 RX(=SX) 모드 테이블 Lock을 먼저 설정해야 한다.

'테이블 Lock'이라고 하면, 테이블 전체에 Lock이 걸린다고 생각하기 쉽지만 DML을 수행하기 전에 항상 테이블 Lock을 먼저 설정하므로 그렇게 이해하는 것은 맞지 않다.

오라클에서 말하는 테이블 Lock은, 자신이 해당 테이블에서 `현재 어떤 작업의 수행 상태(작업을 더 진행할 수 있는지, 없다면 기다릴지, 아니면 포기할지)를 알리는 일종의 푯말`이다.

### Lock을 푸는 열쇠, 커밋
블로킹은 `선행 트랜잭션이 설정한 Lock 때문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰 있는 상태`를 말한다. 이것을 해소하는 방법은 커밋(또는 롤백)뿐이다.

교착상태는 `두 트랜잭션이 각각 특정 리소스에 Lock을 설정한 상태에서 맞은편 트랜잭션이 Lock을 설정한 리소스에 또 Lock을 설정하려고 진행햐는 상황`을 말한다. 교착상태가 발생하면 둘 중 하나가 뒤로 물러나지 않으면 영영 풀릴 수 없다.

오라클에서 교착상태가 발생하면, 이를 먼저 인지한 트랜잭션이 문장 수준 롤백을 진행한 후 에러 메시지를 던진다.

오라클은 `데이터를 읽을 때 Lock을 사용하지 않으므로 다른 DBMS에 비해 상대적으로 Lock 경합이 적게 발생`한다.

그렇더라도 불필요하게 트랜잭션을 길게 정의하지 않도록 주의해야 한다. 트랜잭션이 너무 길면, 트랜잭션을 롤백해야 할 때 너무 많은 시간이 걸려 고생할 수 있다.

`같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 애플리케이션을 설계`해야 하고, DML Lock 때문에 동시성이 저하되지 않도록 `적절한 시점에 커밋`해야 한다.

## 트랜잭션 동시성 제어
동시성 제어는 비관적 동시성 제어와 낙관적 동시성 제어로 나뉜다.

비관적 동시성 제어는 `사용자들이 같은 데이터를 동시에 수정할 것으로 가정`한다. 따라서 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신처리가 완료될 때까지 이를 유지한다. Lock은 첫 번째 사용자가 트랜잭션을 완료하기 전까지 다른 사용자들이 같은 데이터를 수정할 수 없게 만들기 때문에 비관적 동시성 제어를 잘못 사용하면 동시성이 나빠진다.

반면, 낙관적 동시성 제어는 `사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정`한다. 따라서 데이터를 읽을 때 Lock을 설정하지 않는다.

### 비관적 동시성 제어
비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어뜨릴 우려가 있지만, FOR UPDATE에 WAIT 또는 NOWAIT 옵션을 함께 사용하면 Lock을 얻기 위해 무한정 기다리지 않아도 된다.

### 낙관적 동시성 제어
낙관적 동시성 제어에서도 UPDATE 전에 아래 SELECT 문을 한 번 더 수행함으로써(nowait 옵션 사용) Lock에 대한 예외처리를 한다면, 다른 트랜잭션이 설정한 Lock을 기다리지 않게 구현할 수 있다.

### 동시성 제어 없는 낙관적 프로그래밍
낙관적 동시성 제어를 사용하면 Lock이 유지되는 시간이 매우 짧아져 동시성을 높이는 데 매우 유리하다. 하지만 다른 사용자가 같은 데이터를 변경했는지 검사하고 그에 따라 처리 방향성을 결정하는 귀찮은 절차가 뒤따른다.

### 데이터 품질과 동시성 향상을 위한 제언
성능보다 데이터 품질이 더 중요하다. 동의한다면, FOR UPDATE 사용을 두려워하지 말자.

불필요하게 Lock을 오래 유지하지 않고, 트랜잭션의 원자성을 보장하는 범위 내에서 가급적 빨리 커밋하자.

낙관적, 비관적 동시성 제어를 같이 사용하는 방법도 있다. 일단 낙관적 동시성 제어를 시도했다가 다른 트랜잭션에 의해 데이터가 변경된 사실이 발견되면, 롤백하고 다시 시도할 때 비관적 동시성 제어를 사용하는 방식이다.

## 채번 방식에 따른 INSERT 성능 비교
INSERT, UPDATE, DELETE, MERGE 중 `가장 중요하고 튜닝 요소가 많은 것은 INSERT`다. 수행빈도가 가장 높아서 그렇기도 하지만, 채번 방식에 따른 성능 차이가 매우 크기 때문이다.

신규 데이터를 입력하려면 PK 중복을 방지하기 위한 채번이 선행되어야 한다. 가장 많이 사용되는 채번 방식으로는 아래 세 가지가 있다.
- 채번 테이블
- 시퀀스 오브젝트
- MAX + 1 조회

### 채번 테이블
각 테이블 식별자의 단일컬럼 일련번호 또는 구분 속성별 순번을 채번하기 위해 별도 테이블을 관리하는 방식이다. 채번 레코드를 읽어서 1을 더한 값으로 변경하고, 그 값을 새로운 레코드를 입력하는 데 사용한다. 이 방식은 채번 레코드를 변경하는 과정에 자연스럽게 엑세스 직렬화가 이루어지므로 두 트랜잭션이 중복 값을 채번할 가능성을 원천적으로 방지해 준다.

장점부터 나열하면 아래와 같다.
- 범용성이 좋다.
- INSERT 과정에 중복 레코드 발생에 대한 예외 처리를 크게 신경쓰지 않아도 된다.
- INSERT 과정에 결번을 방지할 수 있다.
- PK가 복합컬럼일 때도 사용할 수 있다.

가장 큰 단점은 다른 채번 방식에 비해 성능이 좋지 않다는 점이다. 채번 레코드를 변경하기 위한 로우 Lock 경합 때문이다.

동시 INSERT가 아주 많으면 채번 레코드뿐만 아니라 채번 테이블 블록 자체에도 경합이 발생한다. 따라서 `동시 INSERT가 많은 테이블에는 이 방식을 사용하기 어렵다.`

### 시퀀스 오브젝트
시퀀스의 가장 큰 장점은 성능이 빠르다는 데 있다. 채번 테이블과 마찬가지로 INSERT 과정에 중복 레코드 발생에 대비한 예외처리에 크게 생경쓰지 않아도 된다. 테이블별로 시퀀스 오브젝트를 생성하고 관리하는 부담은 있지만, 개발팀 입장에서는 사용하기 매우 편리하다.

시퀀스의 가장 큰 장점이 성능이지만, 이슈가 없는 것은 아니다. 시퀀스 채번 과정에 발생하는 Lock 때문이다. 시퀀스의 성능 이슈를 이해하려면, `시퀀스 오브젝트가 오라클 내부에서 관리하는 채번 테이블이라는 사실을 이해해야 한다.`

시퀀스 오브젝트도 결국 테이블이므로 값을 읽고 변경하는 과정에 `Lock 메커니즘이 작동`한다. Lock에 의한 성능 이슈가 있지만, 캐시 사이즈를 적절히 조절하면 빠른 성능을 제공한다. 시퀀스에는 자율 트랜잭션 기능도 기본적으로 구현돼 있다.

시퀀스의 가장 큰 단점은 `'기본적으로' PK가 단일컬럼일 때만 사용 가능`하다는 데 있다. PK가 복합컬럼일 때도 사용할 수는 있지만, 최소성 요건을 위배하게 된다.

시퀀스의 또 다른 단점은, `신규 데이터를 입력하는 과정에 결번이 생길 수 있다는 점`이다. 원인은 크게 두 가지다. 첫째, `시퀀스 채번 이후에 트랜잭션을 롤백하는 경우`다. 둘째, `CACHE 옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우`다. 자주 사용하지 않아 캐시에서 밀려나거나 인스턴스를 재기동하는 순간, 캐시돼 있던 번호는 모두 사라지며 디스크에서 다시 읽을 때 그다음 번호부터 읽는다.

### MAX + 1 조회
대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해서 INSERT하는 방식이다.

이 방식의 장점으로는 첫째, 시퀀스 또는 별도의 채번 테이블을 관리하는 부담이 없다. 둘째, 동시 트랜잭션에 의한 충돌이 많지 않으면, 성능이 매우 빠르다. 셋째, PK가 복합컬럼인 경우, 즉 구분 속성별 순번을 채번할 때도 사용할 수 있다. 채번 테이블은 구분 속성 값의 수가 적을 때만 사용할 수 있지만, 이 방식은 값의 수가 아무리 많아도 상관없다.

단점으로는 첫째, 레코드 중복에 대비한 세밀한 예외처리가 필요하다. 둘째, 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능이 많이 나빠질 수 있다. 레코드 중복에 의한 로우 Lock 경합 때문이다. 로우 Lock은 선행 트랜잭션이 커밋 또는 롤백할 때까지 지속된다. 선행 트랜잭션이 롤백하지 않는 한, INSERT는 결국 실패하게 되므로 채번과 INSERT를 다시 실행해야 한다. 이런 현상이 자주 발생하면 성능이 느릴 수밖에 없다.

Lock 경합 요소를 고려한 채번 방식 선택 기준을 정리하면, 다음과 같다.
1. 다중 트랜잭션에 의한 동시 채번이 많지 않으면, 세 가지 방식 중 어느 것을 사용해도 크게 상관은 없다. 하지만, 채번 테이블이나 시퀀스 오브젝트 관리 부담을 고려한다면, 가급적 MAX + 1 방식을 선택하는 것이 좋다.
2. 다중 트랜잭션에 의한 동시 채번이 많고 PK가 단일컬럼 일련번호라면, 시퀀스 방식이 가장 좋다.
3. 다중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종류 개수가 많으면, 중복에 의한 로우 Lock 경합 및 재실행 가능성이 낮다. 그렇다면 시퀀스보다 MAX + 1 방식이 구조적으로 좋다.
4. 대중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종류 개수가 적으면, MAX + 1 방식은 성능에 문제가 생길 수 있다. 그럴 때 순환 옵션을 가진 시퀀스 오브젝트 활용을 고려할 수 있다.

### 시퀀스보다 좋은 솔루션
한 개 이상의 구분 속성과 함께 `뒤쪽에 순번 대신 입력일시를 두는 방식으로 PK 구조를 설계`하면, 채번 또는 INSERT 과정에 생기는 Lock 이슈를 거의 해소할 수 있다.

채번 과정을 생략하고 SYSDATE 또는 SYSTIMESTAMP 함수만 호출하면 되기 때문에 빠르고 간편하다.

### 인덱스 블록 경합
INSERT 성능이 너무 빨라도 문제다. 위 내용대로 설계하면 더는 성능 문제가 없을 거 같지만, 인덱스 경합이라는 복병이 숨어 있다.

인덱스 경합은 Right Growing 인덱스에서 가장 흔히 볼 수 있다. 인덱스에는 키순으로 정렬된 상태를 유지하며 값이 입력된다. 이런 특징을 갖는 인덱스를 'Right Growing 인덱스'라고 부른다. Right Growing 인덱스에는 입력하는 값이 달라도 `같은 블록을 갱신하려는 프로세스 간 버퍼 Lock 경합이 발생할 수 있다.` 이는 여러 프로세스에 의한 동시 INSERT가 많을 때 트랜잭션 성능을 떨어뜨리는 주범이다.

인덱스 블록 경합을 해소하는 가장 일반적인 방법은 `인덱스를 해시 파티셔닝하는 것`이다. 인덱스를 해시 파티셔닝하면, 값이 순차적으로 증가하더라도 해시 함수가 리턴한 값에 따라 서로 다른 파티션에 입력되므로 경합을 줄일 수 있다. 인덱스를 리버스 키 인덱스로 전환하는 방법도 고려할 수 있다.

 ### TODO 시퀀스 Lock

